Linear search iterates over all the elements of the array one by one and checks if the current element is equal to the target element. It is also known as \textbf{sequential search}.

\subsubsection{Steps}

\begin{itemize}
  \item The search space begins in the first element.
  \item Compare the current element of the search space with a \textbf{key}.
  \item The search space proceeds with the next element.
  \item The process continues until the \textbf{key} is found or the total search space is exhausted.
\end{itemize}

\subsubsection{Implementation}

\begin{lstlisting}[style=general]
function linearSearch(arr, n, x) {
  for (int i = 0; i < n; i++)
    if (arr[i] == x)
      return i;
  return -1;
}

int arr = [2, 5, 65, 12, 84];
int n = arr.length;
int x = 65;
int index  = linearSearch(arr, n, x);
\end{lstlisting}

\subsubsection{Time and Space Complexity}

\textbf{Time Complexity}

\begin{itemize}
  \item \textbf{Best case:} the key might be at the first index. The best case is complexity \emph{O(1)}.
  \item \textbf{Worst case:} the key might be at the last index. The worst case is complexity \emph{O(n)}, where \textit{n} is the size of the array.
  \item \textbf{Average case:} \emph{O(n)}.
\end{itemize}

\textbf{Auxiliary Space:} \textit{O(1)} as except for the variable to iterate through the list, no other variable is used.

\subsubsection{Advantages and Disadvantages}

\textbf{Advantages}

\begin{itemize}
  \item Works on sorted or unsorted arrays. It can be used on arrays of any data type.
  \item Does not require any additional memory.
  \item Well-suited for small datasets.
\end{itemize}

\textbf{Dissdvantages}

\begin{itemize}
  \item Time complexity \textit{O(n)}, which is slow for large datasets.
\end{itemize}
